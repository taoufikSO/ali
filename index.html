<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spotify Playlist Analyzer</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1DB954 0%, #191414 100%);
      color:#fff; min-height:100vh; overflow-x:hidden;
    }
    .container { max-width:1200px; margin:0 auto; padding:20px; }
    .header {
      text-align:center; margin-bottom:40px; padding:40px 0;
      background:rgba(0,0,0,.3); border-radius:20px; backdrop-filter:blur(10px);
      border:1px solid rgba(255,255,255,.1);
    }
    .header h1 {
      font-size:3rem; margin-bottom:10px;
      background:linear-gradient(45deg,#1DB954,#1ed760);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
    }
    .header p { font-size:1.2rem; opacity:.9; }
    .auth-section,.main-section {
      background:rgba(0,0,0,.4); border-radius:15px; padding:30px; margin-bottom:30px;
      backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,.1);
    }
    .login-btn,.analyze-btn,.rec-btn {
      background:linear-gradient(45deg,#1DB954,#1ed760); color:#fff; border:none;
      padding:15px 30px; font-size:1.1rem; border-radius:50px; cursor:pointer;
      transition:all .3s ease; box-shadow:0 4px 15px rgba(29,185,84,.3); margin:10px;
    }
    .login-btn:hover,.analyze-btn:hover,.rec-btn:hover {
      transform:translateY(-2px); box-shadow:0 8px 25px rgba(29,185,84,.4);
    }
    .playlist-input {
      width:100%; max-width:600px; padding:15px; margin:15px 0;
      border:2px solid rgba(29,185,84,.5); border-radius:10px;
      background:rgba(255,255,255,.1); color:#fff; font-size:1.1rem;
    }
    .playlist-input::placeholder { color:rgba(255,255,255,.7); }
    .stats-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(250px,1fr)); gap:20px; margin:30px 0; }
    .stat-card {
      background:rgba(255,255,255,.1); padding:25px; border-radius:15px; text-align:center;
      backdrop-filter:blur(5px); border:1px solid rgba(255,255,255,.2); transition:transform .3s ease;
    }
    .stat-card:hover { transform:translateY(-5px); }
    .stat-value { font-size:2.5rem; font-weight:bold; color:#1DB954; margin-bottom:10px; }
    .stat-label { font-size:1.1rem; opacity:.9; }
    .chart-container {
      background:rgba(255,255,255,.1); padding:30px; border-radius:15px; margin:30px 0;
      backdrop-filter:blur(5px); border:1px solid rgba(255,255,255,.2);
    }
    .recommendations {
      background:rgba(29,185,84,.1); border-radius:15px; padding:25px; margin:30px 0;
      border:1px solid rgba(29,185,84,.3);
    }
    .track-item {
      background:rgba(255,255,255,.1); padding:15px; border-radius:10px; margin:10px 0;
      display:flex; align-items:center; gap:15px; transition:transform .3s ease;
    }
    .track-item:hover { transform:translateX(5px); background:rgba(255,255,255,.2); }
    .track-info { flex:1; }
    .track-name { font-weight:bold; font-size:1.1rem; margin-bottom:5px; }
    .track-artist { opacity:.8; }
    .loading { text-align:center; padding:40px; font-size:1.2rem; animation:pulse 2s infinite; }
    .error {
      background:rgba(255,0,0,.2); color:#ff6b6b; padding:15px; border-radius:10px; margin:15px 0;
      border:1px solid rgba(255,0,0,.3);
    }
    .hidden { display:none; }
    .feature-bar { background:rgba(255,255,255,.2); height:20px; border-radius:10px; margin:10px 0; overflow:hidden; }
    .feature-fill { height:100%; background:linear-gradient(45deg,#1DB954,#1ed760); border-radius:10px; transition:width .5s ease; }
    @keyframes pulse { 0%{opacity:1} 50%{opacity:.5} 100%{opacity:1} }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ðŸŽµ Spotify Playlist Analyzer</h1>
      <p>Analyze your playlists and discover new music</p>
    </div>

    <div id="auth-section" class="auth-section">
      <h2>Connect to Spotify</h2>
      <p>Sign in to analyze your playlists and get personalized recommendations</p>
      <button id="login-btn" class="login-btn">Login with Spotify</button>
      <div id="user-info" class="hidden">
        <p>Welcome, <span id="user-name"></span>!</p>
      </div>
    </div>

    <div id="main-section" class="main-section hidden">
      <h2>Analyze a Playlist</h2>
      <input id="playlist-url" class="playlist-input" type="text"
             placeholder="Enter Spotify playlist URL (e.g., https://open.spotify.com/playlist/...)"/>
      <br/>
      <button id="analyze-btn" class="analyze-btn">Analyze Playlist</button>

      <div id="loading" class="loading hidden">Analyzing your playlist...</div>
      <div id="error" class="error hidden"></div>

      <div id="results" class="hidden">
        <h3>Playlist Overview</h3>
        <div id="basic-stats" class="stats-grid">
          <div class="stat-card">
            <div id="track-count" class="stat-value">0</div>
            <div class="stat-label">Tracks</div>
          </div>
          <div class="stat-card">
            <div id="total-duration" class="stat-value">0h 0m</div>
            <div class="stat-label">Total Duration</div>
          </div>
          <div class="stat-card">
            <div id="avg-popularity" class="stat-value">0</div>
            <div class="stat-label">Avg Popularity</div>
          </div>
        </div>

        <div class="chart-container">
          <h3>Audio Features</h3>
          <div id="audio-features"></div>
        </div>

        <div id="recommendations-section" class="recommendations hidden">
          <h3>Recommended Similar Tracks</h3>
          <button id="get-recommendations" class="rec-btn">Get Recommendations</button>
          <div id="recommendations-list"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    class SpotifyPlaylistAnalyzer {
      constructor() {
        this.clientId = 'e1f9fff1018746c09f5b58ce3a1c7c7c';
        this.redirectUri = window.location.hostname === 'localhost'
          ? 'http://localhost:5173/callback'
          : 'https://www.tensflowrevops.com/callback';
        this.scopes = 'user-read-email user-read-private playlist-read-private playlist-read-collaborative';
        this.accessToken = null;
        this.currentPlaylistData = null;
        this.init();
      }

      init() {
        if (window.location.pathname === '/callback') { this.handleCallback(); return; }
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => this.setupAfterDOMReady());
        } else {
          this.setupAfterDOMReady();
        }
      }

      setupAfterDOMReady() {
        this.loadStoredToken();
        this.setupEventListeners();
        this.updateUI();
      }

      setupEventListeners() {
        document.getElementById('login-btn').addEventListener('click', () => this.login());
        document.getElementById('analyze-btn').addEventListener('click', () => this.analyzePlaylist());
        document.getElementById('get-recommendations').addEventListener('click', () => this.getRecommendations());
      }

      generateCodeVerifier() {
        const bytes = new Uint8Array(32);
        crypto.getRandomValues(bytes);
        return btoa(String.fromCharCode.apply(null, bytes))
          .replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      }
      async generateCodeChallenge(verifier) {
        const digest = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(verifier));
        return btoa(String.fromCharCode.apply(null, new Uint8Array(digest)))
          .replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      }

      async login() {
        const verifier = this.generateCodeVerifier();
        const challenge = await this.generateCodeChallenge(verifier);
        localStorage.setItem('spotify_code_verifier', verifier);
        const params = new URLSearchParams({
          response_type: 'code',
          client_id: this.clientId,
          scope: this.scopes,
          redirect_uri: this.redirectUri,
          code_challenge_method: 'S256',
          code_challenge: challenge
        });
        window.location.href = `https://accounts.spotify.com/authorize?${params.toString()}`;
      }

      async handleCallback() {
        const qp = new URLSearchParams(window.location.search);
        const code = qp.get('code');
        const error = qp.get('error');
        if (error) { console.error('Auth error:', error); window.location.href = '/'; return; }
        if (code) { await this.exchangeToken(code); window.location.href = '/'; }
      }

      async exchangeToken(code) {
        const verifier = localStorage.getItem('spotify_code_verifier');
        const res = await fetch('https://accounts.spotify.com/api/token', {
          method:'POST',
          headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
          body:new URLSearchParams({
            grant_type:'authorization_code',
            code,
            redirect_uri:this.redirectUri,
            client_id:this.clientId,
            code_verifier:verifier
          })
        });
        const data = await res.json();
        if (data.access_token) {
          this.storeToken(data);
          localStorage.removeItem('spotify_code_verifier');
        } else {
          console.error('Token exchange failed:', data);
        }
      }

      storeToken(token) {
        const expiresAt = Date.now() + (token.expires_in * 1000);
        localStorage.setItem('spotify_access_token', token.access_token);
        localStorage.setItem('spotify_expires_at', String(expiresAt));
        if (token.refresh_token) localStorage.setItem('spotify_refresh_token', token.refresh_token);
      }

      loadStoredToken() {
        const t = localStorage.getItem('spotify_access_token');
        const exp = localStorage.getItem('spotify_expires_at');
        if (t && exp && Date.now() < parseInt(exp)) {
          this.accessToken = t;
          this.getUserInfo();
        }
      }

      async getUserInfo() {
        try {
          const r = await fetch('https://api.spotify.com/v1/me', {
            headers: { Authorization: `Bearer ${this.accessToken}` }
          });
          if (r.status === 401) { this.clearToken(); return; }
          const u = await r.json();
          document.getElementById('user-name').textContent = u.display_name || 'User';
          this.updateUI();
        } catch (e) {
          console.error('User info error:', e);
          this.clearToken();
        }
      }

      clearToken() {
        localStorage.removeItem('spotify_access_token');
        localStorage.removeItem('spotify_expires_at');
        localStorage.removeItem('spotify_refresh_token');
        this.accessToken = null;
        this.updateUI();
      }

      updateUI() {
        const auth = document.getElementById('auth-section');
        const main = document.getElementById('main-section');
        const userInfo = document.getElementById('user-info');
        const loginBtn = document.getElementById('login-btn');
        if (this.accessToken) {
          userInfo.classList.remove('hidden');
          loginBtn.classList.add('hidden');
          main.classList.remove('hidden');
          auth.style.display = 'none';
        } else {
          userInfo.classList.add('hidden');
          loginBtn.classList.remove('hidden');
          main.classList.add('hidden');
          auth.style.display = 'block';
        }
      }

      extractPlaylistId(url) {
        try {
          const u = new URL(url.trim());
          const parts = u.pathname.split('/');
          const idx = parts.findIndex(p => p === 'playlist');
          if (idx !== -1 && parts[idx + 1]) return parts[idx + 1];
        } catch (_) { /* fall back to regex */ }
        const m = String(url).match(/playlist\/([a-zA-Z0-9]+)/);
        return m ? m[1] : null;
      }

      async analyzePlaylist() {
        const playlistUrl = document.getElementById('playlist-url').value;
        const id = this.extractPlaylistId(playlistUrl);
        if (!id) { this.showError('Please enter a valid Spotify playlist URL'); return; }

        this.showLoading(true); this.hideError();
        try {
          const pRes = await fetch(`https://api.spotify.com/v1/playlists/${id}`, {
            headers: { Authorization: `Bearer ${this.accessToken}` }
          });
          if (pRes.status === 401) { this.clearToken(); throw new Error('Authentication expired. Please login again.'); }
          if (pRes.status === 404) throw new Error('Playlist not found. Make sure it is public or shared with you.');
          if (!pRes.ok) throw new Error(`Failed to fetch playlist: ${pRes.status}`);
          const playlist = await pRes.json();

          // get tracks (paginate)
          let items = [];
          let next = `https://api.spotify.com/v1/playlists/${id}/tracks?limit=50`;
          while (next) {
            const tr = await fetch(next, { headers: { Authorization: `Bearer ${this.accessToken}` } });
            if (!tr.ok) throw new Error(`Failed to fetch tracks: ${tr.status}`);
            const td = await tr.json();
            items = items.concat(td.items || []);
            next = td.next;
          }

          const valid = items.filter(x => x?.track?.id);
          const ids = valid.map(x => x.track.id);

          const features = await this.getAudioFeatures(ids);

          this.currentPlaylistData = { playlist, tracks: valid, audioFeatures: features };
          this.displayResults();
        } catch (e) {
          console.error(e);
          this.showError(`Analysis failed: ${e.message}`);
        } finally {
          this.showLoading(false);
        }
      }

      async getAudioFeatures(trackIds) {
        if (!Array.isArray(trackIds) || trackIds.length === 0) return [];
        const features = [];
        const batchSize = 100;

        for (let i = 0; i < trackIds.length; i += batchSize) {
          const batch = trackIds.slice(i, i + batchSize).filter(Boolean);
          if (batch.length === 0) continue;

          try {
            const r = await fetch(
              `https://api.spotify.com/v1/audio-features?ids=${encodeURIComponent(batch.join(','))}`,
              { headers: { Authorization: `Bearer ${this.accessToken}`, Accept: 'application/json' } }
            );
            if (r.status === 401) throw new Error('Authentication expired while fetching audio features.');
            if (!r.ok) {
              const e = await r.json().catch(() => ({}));
              throw new Error(`Audio features error ${r.status}: ${e.error?.message || 'Unknown'}`);
            }
            const d = await r.json();
            features.push(...(d.audio_features || []).filter(Boolean));
          } catch (err) {
            if (features.length === 0) this.showError(err.message);
          }

          if (i + batchSize < trackIds.length) {
            await new Promise(res => setTimeout(res, 100));
          }
        }

        if (features.length === 0) this.showError('Could not load audio features for this playlist.');
        return features;
        }

      displayResults() {
        const { tracks, audioFeatures } = this.currentPlaylistData;
        const totalMs = tracks.reduce((s, it) => s + (it.track.duration_ms || 0), 0);
        const avgPop = tracks.reduce((s, it) => s + (it.track.popularity || 0), 0) / Math.max(tracks.length, 1);

        document.getElementById('track-count').textContent = tracks.length;
        document.getElementById('total-duration').textContent = this.formatDuration(totalMs);
        document.getElementById('avg-popularity').textContent = Math.round(avgPop);

        this.displayAudioFeatures(audioFeatures);

        document.getElementById('results').classList.remove('hidden');
        document.getElementById('recommendations-section').classList.remove('hidden');
      }

      displayAudioFeatures(features) {
        const container = document.getElementById('audio-features');
        container.innerHTML = '';
        if (!features || features.length === 0) {
          container.innerHTML = '<div style="opacity:.85">No audio features available.</div>';
          return;
        }

        const keys = ['danceability','energy','valence','acousticness','instrumentalness','speechiness'];
        for (const k of keys) {
          const vals = features.map(f => f?.[k]).filter(v => typeof v === 'number');
          if (!vals.length) continue;
          const avg = vals.reduce((s,v)=>s+v,0)/vals.length;

          const wrap = document.createElement('div');
          wrap.style.marginBottom = '15px';
          wrap.innerHTML = `
            <div style="display:flex;justify-content:space-between;margin-bottom:5px;">
              <span style="text-transform:capitalize;font-weight:bold;">${k}</span>
              <span>${(avg*100).toFixed(1)}%</span>
            </div>
            <div class="feature-bar">
              <div class="feature-fill" style="width:${avg*100}%"></div>
            </div>`;
          container.appendChild(wrap);
        }
      }

      calculateAverageFeatures(features) {
        if (!features || !features.length) return {};
        const names = ['danceability','energy','valence','acousticness'];
        const out = {};
        for (const n of names) {
          const vals = features.map(f => f?.[n]).filter(v => typeof v === 'number');
          if (vals.length) out[n] = vals.reduce((s,v)=>s+v,0)/vals.length;
        }
        return out;
      }

      async getRecommendations() {
        if (!this.currentPlaylistData) return;
        const { tracks, audioFeatures } = this.currentPlaylistData;

        this.showLoading(true); this.hideError();
        try {
          const avg = this.calculateAverageFeatures(audioFeatures || []);

          // artist counts
          const artistCounts = {};
          for (const item of tracks) {
            const arts = item?.track?.artists || [];
            for (const a of arts) if (a?.id) artistCounts[a.id] = (artistCounts[a.id] || 0) + 1;
          }
          const topArtists = Object.entries(artistCounts)
            .sort((a,b)=>b[1]-a[1])
            .map(([id])=>id)
            .filter(Boolean);

          // unique track seeds
          const seedTrackPool = [...new Set(tracks.map(it => it?.track?.id).filter(Boolean))];

          const params = new URLSearchParams();
          params.set('limit', '10');
          params.set('market', 'from_token'); // improves availability

          let used = 0;
          const artistSeeds = topArtists.slice(0, Math.min(2, 5));
          if (artistSeeds.length) { params.set('seed_artists', artistSeeds.join(',')); used += artistSeeds.length; }

          if (used < 5 && seedTrackPool.length) {
            const trackSeeds = seedTrackPool.slice(0, 5 - used);
            if (trackSeeds.length) { params.set('seed_tracks', trackSeeds.join(',')); used += trackSeeds.length; }
          }

          if (used === 0) {
            params.set('seed_genres', 'pop'); // safe fallback
          }

          // optional targets
          const t = (k, v) => { if (typeof v === 'number' && v > 0) params.set(`target_${k}`, v.toFixed(3)); };
          t('danceability', avg.danceability);
          t('energy',       avg.energy);
          t('valence',      avg.valence);

          const url = `https://api.spotify.com/v1/recommendations?${params.toString()}`;
          const res = await fetch(url, {
            headers: { Authorization: `Bearer ${this.accessToken}`, Accept:'application/json' }
          });

          if (res.status === 401) { this.clearToken(); throw new Error('Authentication expired. Please login again.'); }
          if (res.status === 400) {
            const e = await res.json().catch(()=>({}));
            throw new Error(`Bad seed parameters: ${e.error?.message || '400'}`);
          }
          if (res.status === 404) throw new Error('No valid seeds. Try another playlist or make it public.');
          if (!res.ok) {
            const e = await res.json().catch(()=>({}));
            throw new Error(`Spotify API error: ${res.status} - ${e.error?.message || 'Unknown'}`);
          }

          const data = await res.json();
          if (!data.tracks || !data.tracks.length) throw new Error('No recommendations found for this playlist.');

          this.displayRecommendations(data.tracks);
        } catch (err) {
          console.error('Recommendations error:', err);
          this.showError(`Recommendations error: ${err.message}`);
        } finally {
          this.showLoading(false);
        }
      }

      displayRecommendations(tracks) {
        const c = document.getElementById('recommendations-list');
        c.innerHTML = '';
        for (const t of tracks) {
          const row = document.createElement('div');
          row.className = 'track-item';
          row.innerHTML = `
            <div class="track-info">
              <div class="track-name">${t.name}</div>
              <div class="track-artist">${(t.artists || []).map(a => a.name).join(', ')}</div>
            </div>
            <a href="${t.external_urls?.spotify || '#'}" target="_blank"
               style="color:#1DB954;text-decoration:none;font-weight:bold;">Open in Spotify</a>`;
          c.appendChild(row);
        }
      }

      formatDuration(ms) {
        const minutes = Math.floor(ms / 60000);
        const hours = Math.floor(minutes / 60);
        const rem = minutes % 60;
        return hours > 0 ? `${hours}h ${rem}m` : `${minutes}m`;
      }

      showLoading(show) { document.getElementById('loading').classList.toggle('hidden', !show); }
      showError(msg) { const e = document.getElementById('error'); e.textContent = msg; e.classList.remove('hidden'); }
      hideError() { document.getElementById('error').classList.add('hidden'); }
    }

    // boot
    new SpotifyPlaylistAnalyzer();
  </script>
</body>
</html>
